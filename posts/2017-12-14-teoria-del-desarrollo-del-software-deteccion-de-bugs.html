<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>josejuan - Teor√≠a del desarrollo del software; detecci√≥n de bugs</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
              <a href="../">josejuan <s>blog</s></a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">Acerca de</a>
                <a href="../archive.html">Archivo</a>
            </div>
        </div>

        <div id="content">
            <h1>Teor√≠a del desarrollo del software; detecci√≥n de bugs</h1>

            <div class="info">
    Posted on December 14, 2017
    
        by josejuan
    
</div>

<p>De forma recurrente me sorprendo por el (aparentemente) poco inter√©s en aplicar t√©cnicas <em>‚Äúancestrales‚Äù</em> al desarrollo del software que en otras √°reas han dado tan buenos resultados. La estad√≠stica y el c√°lculo de probabilidades (desde el genial <em>conde de Buffon</em>) se aplica con enorme √©xito en sistemas complejos de analizar de forma determinista. Desde hace bastante tiempo me pregunto por qu√© no veo cosas como <em>‚ÄúSi la P d q cualquier c√≥digo tuyo tenga bugs es dl 50% y la d q tu test los descubra es dl 50%, tu c√≥digo es buggy en ~38% pues P‚âàB(1-D+DB)‚Äù</em> <a href="https://twitter.com/__josejuan__/status/648138545660620800">üê¶ </a>.</p>
<p>En el desarrollo de <em>software</em> sin duda hay muchas <strong>opiniones</strong>, pero no muchas t√©cnicas contrastadas con una s√≥lida base te√≥rica que ayuden (sobre todo a grandes equipos de desarrollo) a medir y dirigir los recursos hacia los <em>‚Äúpuntos calientes‚Äù</em> de la aplicaci√≥n. Ya no digamos para t√©cnicas m√°s sofisticadas como <em>‚Äú¬øTe imaginas un lenguaje que te pidiera anotaciones (ej. de tipo) bas√°ndose en la probabilidad de bug (rojo) o de optimizaci√≥n (naranja)?‚Äù</em> <a href="https://twitter.com/__josejuan__/status/406050784984309760">üê¶ </a>.</p>
<p>Como son pocos y √©ste me ha gustado, me apetec√≠a tenerlo traducido.</p>
<p><strong>T√≠tulo original:</strong> <a href="http://stevemcconnell.com/articles/gauging-software-readiness-with-defect-tracking/"><em>‚ÄúGauging Software Readiness With Defect Tracking‚Äù</em></a> <em>(Vol. 14, No. 3, May/June 1997)</em></p>
<hr />
<p>En el competitivo mercado de software comercial, las empresas de software se sienten obligadas a lanzar software en el momento en que est√° listo. Su tarea es traicionera, pisando la l√≠nea divisoria entre liberar software de mala calidad temprano y software de alta calidad tarde. Una buena respuesta a la pregunta <em>‚Äú¬øEs el software lo suficientemente bueno para lanzarlo ahora?‚Äù</em> puede ser cr√≠tico para la supervivencia de una empresa. La respuesta a veces se basa en el instinto visceral, pero varias t√©cnicas pueden poner este juicio sobre una base m√°s firme.</p>
<h2 id="densidad-de-bugs">Densidad de <em>bugs</em></h2>
<p>Una de las maneras m√°s f√°ciles de juzgar si un programa est√° listo para ser liberado es medir su densidad de <em>bugs</em> - el n√∫mero de <em>bugs</em> por l√≠nea de c√≥digo. Suponga que la primera versi√≥n de su producto, GigaTron 1.0, consistiera en 100.000 l√≠neas de c√≥digo, que usted detect√≥ 650 <em>bugs</em> antes de la publicaci√≥n del software, y que se reportaron 50 <em>bugs</em> m√°s despu√©s de la publicaci√≥n del software. Por lo tanto, el software ten√≠a un n√∫mero total de 700 <em>bugs</em>, y una densidad de <em>bugs</em> de 7 <em>bugs</em> por cada mil l√≠neas de c√≥digo (KLOC).</p>
<p>Supongamos que GigaTron 2.0 consisti√≥ en 50.000 l√≠neas de c√≥digo adicionales, que usted detect√≥ 400 <em>bugs</em> antes de la liberaci√≥n, y otros 75 despu√©s de la liberaci√≥n. La densidad total de <em>bugs</em> de esa liberaci√≥n ser√≠a de 475 <em>bugs</em> totales divididos entre 50.000 nuevas l√≠neas de c√≥digo, o 9.5 <em>bugs</em> por KLOC.</p>
<p>Ahora suponga que est√° tratando de decidir si GigaTron 3.0 es lo suficientemente confiable como para entregarlo. Consta de 100.000 nuevas l√≠neas de c√≥digo, y ha detectado 600 <em>bugs</em> hasta ahora, o 6 <em>bugs</em> por KLOC. A menos que tenga una buena raz√≥n para pensar que su proceso de desarrollo ha mejorado con este proyecto, su experiencia le llevar√° a esperar entre 7 y 10 <em>bugs</em> por KLOC. El n√∫mero de <em>bugs</em> que usted debe intentar encontrar variar√° dependiendo del nivel de calidad que est√° buscando. Si desea eliminar el 95 por ciento de todos los <em>bugs</em> antes de la liberaci√≥n, deber√° detectar entre 650 y 950 <em>bugs</em> antes del lanzamiento. Esta t√©cnica sugiere que el producto no est√° listo para su env√≠o.</p>
<p>Cuantos m√°s datos de proyecto hist√≥ricos tenga, m√°s confianza tendr√° en sus objetivos de densidad de <em>bugs</em> previos a la liberaci√≥n. Si usted tiene datos de s√≥lo dos proyectos y el rango es tan amplio como 7 a 10 <em>bugs</em> por KLOC, eso deja mucho espacio para un juicio experto sobre si el tercer proyecto ser√° m√°s parecido al primero o segundo. Pero si usted ha rastreado los datos de <em>bugs</em> para 10 proyectos y ha encontrado que su tasa promedio de <em>bugs</em> de por vida es de 7.4 <em>bugs</em> por KLOC con una desviaci√≥n est√°ndar de 0.4 <em>bugs</em>, usted puede tener confianza en esos datos.</p>
<h2 id="agrupaci√≥n-de-bugs">Agrupaci√≥n de <em>bugs</em></h2>
<p>Otra t√©cnica sencilla de predicci√≥n de <em>bugs</em> consiste en separar los informes de <em>bugs</em> en dos grupos. Ll√°melos grupo A y grupo B. A continuaci√≥n, realice un seguimiento de los <em>bugs</em> en estos dos grupos por separado. La distinci√≥n entre los dos grupos es arbitraria. Podr√≠a poner todos los <em>bugs</em> descubiertos los lunes, mi√©rcoles y fines de semana en el grupo A, y el resto de los <em>bugs</em> en el grupo B. O podr√≠as dividir a su equipo de pruebas por el medio y poner la mitad de sus <em>bugs</em> reportados en un grupo, la mitad en el otro. No importa realmente c√≥mo se haga la divisi√≥n, siempre y cuando ambos grupos de informes operen independientemente y ambos prueben el alcance completo del producto.</p>
<p>Una vez que se crea una distinci√≥n entre los dos grupos, se realiza un seguimiento del n√∫mero de <em>bugs</em> notificados en el grupo A, el n√∫mero en el grupo B y (aqu√≠ est√° la parte importante) el n√∫mero de <em>bugs</em> que se notifican tanto en el grupo A como en el grupo B. El n√∫mero de <em>bugs</em> √∫nicos notificados en un momento dado es:</p>
<p><em>bugs</em><sub>√önicos</sub> = <em>bugs</em><sub>A</sub> + <em>bugs</em><sub>B</sub> - <em>bugs</em><sub>AyB</sub></p>
<p>El n√∫mero de <em>bugs</em> totales puede entonces ser aproximado por la f√≥rmula:</p>
<p><em>bugs</em> <sub>Total</sub> = (<em>bugs</em><sub>A</sub> * <em>bugs</em><sub>B</sub>) / <em>bugs</em><sub>AyB</sub></p>
<p>Si el proyecto GigaTron 3.0 tiene 400 <em>bugs</em> en el grupo A, 350 <em>bugs</em> en el grupo B y 150 de los <em>bugs</em> en ambos grupos, el n√∫mero de <em>bugs</em> √∫nicos detectados ser√≠a de 400 + 350 - 150 = 600. Si el proyecto GigaTron 3.0 tiene 400 <em>bugs</em> en el grupo A, 350 <em>bugs</em> en el grupo B y 150 de los <em>bugs</em> en ambos grupos, el n√∫mero de <em>bugs</em> √∫nicos detectados ser√≠a de 400 + 350 - 150 = 600. El n√∫mero aproximado de <em>bugs</em> totales ser√≠a 400 * 350 / 150 = 933. Esta t√©cnica sugiere que quedan por detectar aproximadamente 333 <em>bugs</em> (aproximadamente un tercio de los <em>bugs</em> totales estimados); el aseguramiento de la calidad en este proyecto todav√≠a tiene un largo camino por recorrer.</p>
<h2 id="sembrado-de-bugs">Sembrado de <em>bugs</em></h2>
<p>La siembra de <em>bugs</em> es una pr√°ctica en la que un grupo inserta intencionadamente <em>bugs</em> en un programa para su detecci√≥n por otro grupo. La relaci√≥n entre el n√∫mero de <em>bugs</em> detectados y el n√∫mero total de <em>bugs</em> sembrados proporciona una idea aproximada del n√∫mero total de <em>bugs</em> no sembrados que se han detectado.</p>
<p>Suponga que en GigaTron 3.0 ha introducido intencionalmente el programa con 50 errores. Para obtener el mejor efecto, los errores sembrados deben cubrir la totalidad de la funcionalidad del producto y toda la gama de severidades, desde errores de colisi√≥n hasta errores cosm√©ticos.</p>
<p>Suponga que en un punto del proyecto, cuando usted crea que las pruebas est√°n casi completas, mira el informe del <em>bug</em> sembrado. Usted encuentra que se han reportado 31 <em>bugs</em> sembrados y 600 <em>bugs</em> <em>‚Äúreales‚Äù</em>. Se puede estimar el n√∫mero total de <em>bugs</em> con la f√≥rmula:</p>
<p><em>reales</em><sub>Totales</sub> = (<em>sembrados</em><sub>Totales</sub> / <em>sembrados</em><sub>Encontrados</sub>) * <em>reales</em><sub>Encontrados</sub></p>
<p>Esta t√©cnica sugiere que GigaTron 3.0 tiene aproximadamente 50 / 31 * 600 = 967 <em>bugs</em> totales.</p>
<p>Para utilizar la siembra de <em>bugs</em>, debe sembrar los <em>bugs</em> antes del comienzo de las pruebas cuya eficacia desea determinar. Si su prueba utiliza m√©todos manuales y no tiene una manera sistem√°tica de cubrir el mismo campo de pruebas dos veces, usted debe sembrar <em>bugs</em> antes de que comience la prueba. Si su prueba utiliza pruebas de regresi√≥n completamente automatizadas, usted puede sembrar <em>bugs</em> virtualmente en cualquier momento para determinar la efectividad de las pruebas automatizadas.</p>
<p>Un problema com√∫n con los programas de sembrado de <em>bugs</em> es el olvido de eliminar los <em>bugs</em> sembrados. Otro problema com√∫n es que la eliminaci√≥n de los <em>bugs</em> sembrados introduce nuevos errores. Para prevenir estos problemas, aseg√∫rese de eliminar todos los <em>bugs</em> sembrados antes de las pruebas finales del sistema y la liberaci√≥n del producto. Un est√°ndar de implementaci√≥n √∫til para los errores sembrados es exigir que s√≥lo se implementen a√±adiendo una o dos l√≠neas de c√≥digo que crean el error; este est√°ndar garantiza que puede eliminar los errores sembrados de forma segura simplemente eliminando las l√≠neas de c√≥digo err√≥neas.</p>
<h2 id="modelado-de-bugs">Modelado de <em>bugs</em></h2>
<p>Un colega m√≠o recientemente agreg√≥ varios cientos de l√≠neas de c√≥digo a un programa existente en una sola sesi√≥n. La primera vez que compil√≥ el c√≥digo, obtuvo una compilaci√≥n limpia sin errores. Su codificaci√≥n inicial parec√≠a ser perfecta. Sin embargo, cuando intent√≥ probar la nueva funcionalidad, descubri√≥ que no exist√≠a. Cuando reexamin√≥ su nuevo c√≥digo, descubri√≥ que su trabajo hab√≠a sido incrustado entre un preprocesador de macros que desactivaba el nuevo c√≥digo. Cuando movi√≥ el nuevo c√≥digo fuera del alcance de la macro, produjo el n√∫mero habitual de errores del compilador.</p>
<p>Con los <em>bugs</em> de software, ninguna noticia suele ser mala noticia. Si el proyecto ha llegado a una etapa tard√≠a con pocos <em>bugs</em> reportados, hay una tendencia natural a pensar: ‚ÄúFinalmente lo hicimos bien y creamos un programa con casi ning√∫n <em>bug</em>‚Äù En realidad, ninguna noticia es m√°s a menudo el resultado de pruebas insuficientes que de pr√°cticas superlativas de desarrollo.</p>
<p>Algunas de las herramientas m√°s sofisticadas de estimaci√≥n y control de proyectos de software contienen una funcionalidad de modelado de <em>bugs</em> que puede predecir el n√∫mero de <em>bugs</em> que se espera encontrar en cada punto del proyecto. Comparando los <em>bugs</em> realmente detectados con el n√∫mero pronosticado, usted puede evaluar si su proyecto se mantiene al d√≠a con la detecci√≥n de <em>bugs</em> o si se queda rezagado.</p>
<h2 id="combinaciones">Combinaciones</h2>
<p>Evaluar las combinaciones de densidad de <em>bugs</em>, grupos de <em>bugs</em> y siembra de <em>bugs</em> le dar√° m√°s confianza de la que podr√≠a tener en cualquiera de las t√©cnicas individualmente. Examinando la densidad del <em>bug</em> solo en GigaTron 3.0 sugiri√≥ que usted debe esperar 700 a 1000 <em>bugs</em> totales, y que usted debe quitar 650 a 950 antes de la liberaci√≥n del producto para alcanzar el 95 por ciento de eliminaci√≥n del <em>bug</em> antes de la liberaci√≥n. Si usted ha detectado 600 <em>bugs</em>, la informaci√≥n de densidad de <em>bugs</em> por s√≠ sola podr√≠a llevarle a declarar el producto ‚Äúcasi listo para enviar‚Äù, pero el an√°lisis de agrupaci√≥n de <em>bugs</em> calcula que GigaTron 3.0 producir√° aproximadamente 933 <em>bugs</em> totales. Comparando los resultados de esas dos t√©cnicas sugiere que usted debe esperar un conteo total de <em>bugs</em> hacia el extremo superior del rango de densidad de <em>bugs</em> en lugar del extremo inferior. Debido a que la t√©cnica de siembra de <em>bugs</em> tambi√©n estima un n√∫mero total de <em>bugs</em> en los 900s, GigaTron 3.0 parece ser un programa relativamente defectuoso.</p>
<h2 id="recursos">Recursos</h2>
<p>La literatura popular no tiene mucho que decir sobre la predicci√≥n de <em>bugs</em>. Una excepci√≥n notable es el libro de Glenford Myers de 1976, Software Reliability (Wiley). Lawrence H. Putnam y Ware Myers discuten el tema espec√≠fico del modelado de <em>bugs</em> con cierta profundidad en Measures for Excellence (Yourdon Press 1992).</p>
<h3 id="referencias">Referencias</h3>
<ul>
<li><a href="http://stevemcconnell.com/articles/gauging-software-readiness-with-defect-tracking/">Gauging Software Readiness With Defect Tracking</a></li>
</ul>

<div id="disqus_thread"></div>
<script>
(function() {
  var d = document, s = d.createElement('script');
  s.src = '//josejuan-github-io.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-3981685-5', 'auto');ga('send', 'pageview');
        </script>
    </body>
</html>
